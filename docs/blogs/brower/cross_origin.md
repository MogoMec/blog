---
title: 同源策略与跨域解决方案及其使用场景
categories: 浏览器
tags: 
- CORS
---

前端开发中，除非你只写一些简单的独立静态页面，否则是一定会遇到跨域问题的。跨域问题产生的根源是浏览器的**同源策略**，在没有设置跨域方案的情况下，出于安全考虑，浏览器会针对你的js脚本，阻止你的各种请求，这是很让人抓狂的。所以，了解同源策略以及各种跨域方案是很有必要的，或许你已经背过不少相关的面试题，但是我认为，跨域是一个很实际的工程问题，不同场景下选择的方案也有所不同（这也是一个局部技术选型问题），而网上的大部分跨域文章仅仅是阐述了方案本身，却忽略了适用场景的分析。本文对各种跨域方案的使用场景也做了总结，希望对你有所帮助。笔者的开发经验尚浅，有疏漏错误欢迎留言。

## 同源策略

**同源策略**是一个重要的**安全策略**，**同源**的定义非常明确，这里直接援引MDN上的定义：

> 如果两个 URL 的协议 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、端口[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 域名[host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。

举个例子，对于`http://www.google.com/index.html`来说，其协议是`http`，域名是 `www.google.com` ，端口号是 `80` （`http`协议默认端口号），结合同源的定义，我们可以判断下列URL是否与该链接同源：

- `http://www.google.com/index2.html`：同源
- `https://www.google.com/index.html`：不同源（协议不同，该URL协议为`https`）
- `http://google.com/index.html`：不同源（域名不同）

- `http://www.google.com:81/index.html`：不同源（端口不同）

具备了判断两个URL是否同源的能力，就可以说说同源策略了。

简单来说，同源策略就是一个源在未经允许（设置跨域）的情况不能访问与其不同源的内容。同源策略主要是针对的是**`JavaScript`脚本**对另一个源中的内容的读写操作，同源策略的存在保障了源中信息的安全，保证了源及其内容的封闭性，没有同源策略，意味着`cookie`等认证信息也可能会被轻易窃取。

## 跨域方案

尽管同源策略一定程度上保障了信息安全，但同时也阻止了我们需要的资源请求，比如使用第三方API获取其他源的数据。为了能够解决同源策略对功能需求实现的影响，我们需要跨域解决方案，并了解其适用场景。

常见的跨域解决方案有：

- CORS（服务端解决）
- jsonp（前端与服务端配合）
- 代理服务器（前端独立解决，开发环境适用）

### CORS

`CORS`全称"跨域资源共享"（Cross-origin resource sharing），名字就很直白，它是一个**W3C标准**，是`HTTP`的一部分，你可以把它理解为官方跨域解决方案。`CORS`方案应该是目前最常用的跨域解决方案（我觉得的，没有数据支撑），其实现的关键是**服务端**，具体使用（不讨论内部机制）也相对简单，只需要在服务端添加一个响应头部：

```js
//koa
ctx.set('Access-Control-Allow-Origin', '*') // *代表任意源
ctx.set('Access-Control-Allow-Origin', 'http://localhost:3000') // 指定源
```

响应头字段名称一直都是那么直白易懂，访问控制允许来源（Access-Control-Allow-Origin）设置为`*`代表任意源，即无论什么源的请求都给予访问权限，听起来就很不安全，如果你对网络安全有所了解，应该不难发现这等于向`CSRF`攻击敞开怀抱，所以我们应该设置指定源，减少不安全的暴露。实际上，`CORS`请求也分为简单请求和复杂请求，并有不同的执行机制，详见阮一峰老师的[跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html)。

`CORS`是在**服务端**（被请求方）设置响应头开放权限的方法，所以对于前端来说，如果服务端压根没有设置`CORS`，在该方案上前端是没有什么操作空间的。比如说你使用了一个第三方`API`，但是它的服务端并没有设置`CORS`，那么你是不能仅仅通过浏览器来进行跨域请求的。

### jsonp

`jsonp`是在`CORS`普及之前最经典的跨域解决方案。jsonp的跨域实现的原理是利用了使用`<script>`加载资源时不受影响（同源策略针对`JavaScript`脚本，不针对`HTML`标签）。也正是因为这个原因，`jsonp`只支持`GET`请求，也容易受到`XSS`攻击。`jsonp`的实现也**需要服务端**的配合。

让我们来看一个简单的`jsonp`实现，

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<body>
<script src="http://www.example.com:5000/data.js?callback=showDate"></script>
<script>
    function showDate(data) {
        console.log(data)
    }
</script>
</body>
</html>
```

首先我们使用`<script>`向服务端发起请求，服务端会返回一个`JavaScript`脚本并解析执行。注意这里我们在URL中写入了一个回调函数名作为参数。

然后我们需要在浏览器端创建并实现该回调函数，主要作用就是解析传入的数据。服务器端需要将回调参数名（请求url中传入）和数据结合在一起，作为传回的JS脚本。

最后，浏览器收到的JS脚本中就已包含了所需数据，并会执行相应的已经设置好的回调函数解析数据。

可以看出来`jsonp`方法是一个利用浏览器构造渲染特性创造出的方案，非标但是在以前很管用，只不过它也有请求方式单一、容易受到XSS攻击的缺点，相对于`CORS`，它也需要前后端更多的配合。

### 代理服务器

同源策略是浏览器的策略，如果是两个服务器之间通信，压根就不会受到同源策略影响。代理服务器方案就是依赖于此，通过设置一个代理服务器（该服务器能够和源内脚本正常通信）来作为中间传话人，由代理服务器向真正的目标服务器发起请求并将获得的数据传回给`JavaScript`脚本。代理服务器方案可以由**前端独立**实现。

本地开发时我们常常使用`webpack-dev-server`，它是是`webpack`官方提供的一个小型`Express`服务器，用于打包生成的静态文件提供服务是实现热更新。想必你已经注意到了，这是个**服务器**，它所提供的服务运行在和你的脚本同源的地方，实际上本地开发测试时的`JavaScript`脚本也是从这获取的。换句话说，它有条件做作为代理服务器解决跨域问题，实际上，它确确实实也支持代理服务器设置。我们只需要在配置文件中配置`proxy`选项，就能完美解决跨域问题。但是需要注意的是，`webpack`是你的开发依赖，你不可能在项目真正上线的时候依靠它来解决跨域。







